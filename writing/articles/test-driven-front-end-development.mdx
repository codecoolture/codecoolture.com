---
canonical: "https://octuweb.com/test-driven-front-end-development/"
date: "2020-11-01"
spoiler:
  "El desarrollo de cualquier aplicaci√≥n web es complejo. Hay un mont√≥n de funcionalidad por crear y, seguramente, poco
  tiempo ü§Ø Sin embargo, con la nueva generaci√≥n de herramientas front-end hay una metodolog√≠a que nos puede ayudar a no
  perder el foco y entregar valor de manera continua, con confianza."
title: "Test-driven front-end development"
url: "/blog/test-driven-front-end-development"
---

# Test-driven front-end development

> Este art√≠culo fue publicado originalmente en la edici√≥n de 2020 de
> [Octuweb](https://octuweb.com/test-driven-front-end-development/).

En la edici√≥n de 2018 **Cristina Ponce** public√≥ [Testing en el front](https://octuweb.com/testing-front/), una gu√≠a
sobre los diferentes tipos de pruebas que podemos realizar en aplicaciones front-end. Apoy√°ndonos en ese art√≠culo, vamos
a hablar aqu√≠ de c√≥mo aprovechar la nueva generaci√≥n de herramientas para alcanzar flujos de desarrollo que, hasta hace
solo unos a√±os, no eran (tan) f√°cilmente aplicables en este contexto: **Test-Driven Development** (o **TDD**).

## Pero primero, ¬øqu√© es TDD?

Test-Driven Development es una metodolog√≠a que se basa en aplicar peque√±os ciclos de desarrollo con el objetivo de
resolver casos de prueba. De manera m√°s concreta, lo podemos definir en 3 pasos:

1. Codificar una prueba que defina el nuevo comportamiento que queremos a√±adir a nuestro sistema
2. Escribir la menor cantidad de c√≥digo posible que nos permita hacer pasar el test anterior
3. Mejorar el c√≥digo anterior utilizando las pruebas como red de seguridad (a.k.a _refactoring_)

En TDD cl√°sico, lo habitual es comenzar por las entidades m√°s internas de nuestro sistema para ir construyendo capas una
encima de otra hasta terminar de implementar la funcionalidad. En front-end sin embargo, y con las herramientas
actuales, lo m√°s natural es utilizar una variaci√≥n denominada **ATDD** (inspirada en **Outside-in**, un enfoque de TDD
que se origin√≥ en la comunidad de eXtreme Programming de Londres), donde se empieza creando un primer test en la capa
m√°s externa del sistema (en este caso, la interfaz o un componente) para ir construyendo desde ah√≠ el resto de la
funcionalidad.

## Escribiendo nuestro primer test

En su sentido m√°s estricto, TDD es una herramienta de desarrollo (un flujo de trabajo, una metodolog√≠a) y no tiene que
verse como un instrumento de calidad (entendiendo esta como la disciplina para el control de defectos). Por tanto, su
objetivo es ayudar a las programadoras a entregar valor lo antes posible, con confianza. En ATDD, por ejemplo, el primer
test nos tiene que permitir poner el foco en el problema que vamos a resolver y servirnos como gu√≠a durante el
desarrollo de la funcionalidad. Lo habitual es intentar reflejar en este primer test los criterios de aceptaci√≥n que
perseguimos cumplir con la historia de usuario en curso.

Por ejemplo, supongamos que estamos trabajando en el front-end para la web de una editorial de libros y queremos a√±adir
una p√°gina de contacto:

> Es posible acceder a una p√°gina de contacto para, indicando email, asunto y mensaje, ponerse en contacto con la
> editorial. Una vez completada la operaci√≥n, se realizar√° una redirecci√≥n a una p√°gina de √©xito con un mensaje que
> indique que todo ha ido bien.
>
> Hay disponible un endpoint `/api/contact` que completa la operaci√≥n en el back-end.

Utilizando [**Cypress**](https://www.cypress.io/), podemos trasladar esta descripci√≥n a una prueba de alto nivel como la
siguiente:

```tsx
// Location: cypress/integration/sendContactMessage.test.ts

context("sendContactMessage", () => {
  specify("A user can send a contact message", () => {
    // Setup
    cy.server();
    cy.route2("/api/contact", { statusCode: 200 });

    // Act
    cy.visit("/contact");
    cy.findByLabelText(/tu email/i).type("hola@codecoolture.com");
    cy.findByLabelText(/asunto/i).type("Informaci√≥n sobre pr√≥ximos libros");
    cy.findByLabelText(/mensaje/i).type("Hola, me gustar√≠a obtener m√°s informaci√≥n sobre pr√≥ximos libros.");
    cy.findByText(/enviar/i).click();

    // Assert
    cy.url().should("eql", Cypress.config().baseUrl + "/contact/success");
    cy.findByText(/tu mensaje ha sido enviado con √©xito/i).should("exist");
  });
});
```

La prueba anterior codifica el escenario de aceptaci√≥n b√°sico: primero, hacemos que Cypress simule la respuesta al
endpoint `/api/contact` para indicar que todo ha ido bien (devolver√° un c√≥digo `200`), y despu√©s interactuamos con la
aplicaci√≥n para ir a la p√°gina de contacto y completar el formulario. Por √∫ltimo, validamos que se ha llevado al usuario
a la p√°gina de √©xito tras enviar el formulario.

> Ahora que hemos visto un ejemplo, seguramente nos sea m√°s sencillo explicar qu√© es Cypress: un framework de testing
> para construir pruebas de aceptaci√≥n sobre un navegador, utilizando JavaScript.

En el ejemplo anterior, la prueba se ejecutar√° sobre nuestra propia aplicaci√≥n. En este caso, **como todav√≠a no hemos
escrito c√≥digo de producci√≥n, lo que esperamos es que el test falle**. Es ahora cuando tenemos que escribir la m√≠nima
cantidad posible de c√≥digo para que este test pueda pasar.

```tsx
// Location: pages/contact.tsx

export default function Contact() {
  return (
    <main>
      <Formik
        initialValues={{ email: "", subject: "", message: "" }}
        onSubmit={async ({ email, subject, message }) => {
          const response = await fetch("/api/contact", {
            body: JSON.stringify({ email, subject, message }),
            headers: { "content-type": "application/json" },
            method: "post",
          });

          if (response.ok) {
            window.location.href = "/contact/success";
          }
        }}
      >
        {() => {
          return (
            <Form>
              <label>
                Tu email <Field id="email" name="email" />
              </label>
              <label>
                Asunto <Field name="subject" />
              </label>
              <label>
                Mensaje <Field name="message" />
              </label>
              <button type="submit">Enviar</button>
            </Form>
          );
        }}
      </Formik>
    </main>
  );
}
```

```tsx
// Location: pages/contact/success.tsx

export default function ContactSuccess() {
  return <p>¬°Enhorabuena! Tu mensaje ha sido enviado con √©xito</p>;
}
```

Obviando algunos detalles de implementaci√≥n (como el uso de [Formik](https://formik.org/) para el formulario), los dos
fragmentos de c√≥digo anteriores muestran una posible implementaci√≥n (b√°sica pero funcional) que sirve para hacer pasar
nuestro primer test de aceptaci√≥n. En este punto, podemos a√±adir CSS a nuestra nueva p√°gina o extraer comportamientos a
otro tipo de entidades (por ejemplo, mover la operaci√≥n de `onSubmit` a un servicio). Si nuestro test sigue en verde al
completar los cambios, tendremos la certeza de que no hemos roto nada ‚úÖ

## Aplicando ciclos de desarrollo m√°s peque√±os

Aunque Cypress es un magn√≠fico framework de testing, las pruebas de tan alto nivel suelen venir con algunos compromisos:
es dif√≠cil poder ejercitar todos los caminos de ejecuci√≥n posibles y son lentas. Recordad que con TDD estamos buscando
mejorar nuestra productividad por lo que **necesitamos que los ciclos de feedback sean lo m√°s cortos posibles**. Para
ello, mi consejo es utilizar pruebas de aceptaci√≥n para cubrir el _happy path_ de la funcionalidad (y quiz√°s alg√∫n
escenario de error clave) y despu√©s iterar en ciclos de desarrollo m√°s peque√±os facilitados por pruebas de una
granularidad m√°s baja (en front-end, podr√≠amos entenderlas como h√≠bridos de integraci√≥n + unitaria, centradas en
componentes).

Si volvemos al ejemplo anterior, seguramente hay ciertas reglas de experiencia de usuario que queramos validar sobre el
formulario de contacto: que no se pueda completar la operaci√≥n sin un email de remite o sin el cuerpo del mensaje, que
aparezcan correctamente los mensajes de error, que los campos permitan √∫nicamente ciertos patrones, etc. Aunque estas
pruebas se podr√≠an hacer tambi√©n utilizando Cypress, su latencia es a menudo lo suficientemente grande como para
preferir moverlos a tests de m√°s bajo nivel (por lo general, m√°s r√°pidos).

Para hacer pruebas de componentes (en React, aunque las mismas herramientas est√°n disponibles en otros frameworks como
Vue o Angular) mi consejo es utilizar [**Testing Library**](https://testing-library.com/) en conjunci√≥n con
[**Jest**](https://jestjs.io/). Por ejemplo, vamos a a√±adir un nuevo comportamiento a nuestra p√°gina de Contacto, aunque
esta vez iterando en un nivel de abstracci√≥n m√°s bajo:

> El formulario s√≥lo debe enviarse si contiene un email de remite y un mensaje.

```tsx
// Location: components/ContactForm.test.tsx

describe("ContactForm", () => {
  it("does not submit the form if some required fields are missing", async () => {
    // Setup
    const spy = jest.fn();
    render(<ContactForm onSubmit={spy} />);

    // Act
    await user.type(screen.getByLabelText(/asunto/i), "Informaci√≥n pr√≥ximos libros");
    user.click(screen.getByText(/enviar/i));

    // Assert
    await expect(screen.findAllByText("Este campo es obligatorio.")).resolves.toHaveLength(2);
    await waitFor(() => expect(spy).not.toHaveBeenCalled());
  });
});
```

El test anterior codifica el nuevo comportamiento que queremos validar. Ver√©is que, en un primer vistazo, la apariencia
del test es similar al primero que creamos utilizando Cypress. La √∫nica diferencia es que aqu√≠ se prueba el componente
de manera aislada en lugar de simular a un usuario real utilizando la aplicaci√≥n. En Testing Library, no hay ning√∫n
navegador ejecut√°ndose en paralelo, como s√≠ ocurre con Cypress; as√≠, mientras el √∫ltimo que hemos escrito podemos
ejecutarlo en ~2 segundos, el primero necesita de ~22 segundos.

Cuando trabajamos a un nivel de granularidad m√°s bajo, nuestros tests pueden afectar al dise√±o de nuestros componentes
(por lo general, haci√©ndolos m√°s sencillos de probar). En este caso, he decidido inyectar la funci√≥n que gestiona el
env√≠o del formulario para poder reemplazarla por un esp√≠a que me permita validar que no se ha invocado cuando no deb√≠a
(aunque tambi√©n podr√≠amos haber espiado el m√≥dulo HTTP con [**nock**](https://github.com/nock/nock)). Este es otro de
los beneficios clave de TDD, ser capaces de ir definiendo el dise√±o de nuestras interfaces a medida que escribimos las
pruebas.

Como todos estos cambios no est√°n repercutiendo en cambios de comportamiento a nivel de aceptaci√≥n, nuestro test de
Cypress deber√≠a seguir pasando despu√©s de cada modificaci√≥n, ayud√°ndonos de nuevo a garantizar que no hemos roto nada
‚úÖ.

Ahora, al igual que en el ejercicio anterior, tendr√≠amos que escribir la menor cantidad de c√≥digo que sirva para hacer
pasar este test.

> Pss! Pod√©is ver el ejemplo completo en [este repositorio de GitHub](https://github.com/codecoolture/octuweb-2020) üëÄ

## Conclusi√≥n

¬øQue conseguiremos aplicando un flujo similar al anterior? En la literatura de TDD, estar√≠amos aplicando lo que se
conoce como
[Outside-In development with Double Loop TDD](http://coding-is-like-cooking.info/2013/04/outside-in-development-with-double-loop-tdd/)
o el proceso descrito en el libro
[Growing Object-Oriented Software, Guided by Tests](https://www.goodreads.com/book/show/4268826-growing-object-oriented-software-guided-by-tests).

Primero, arrancamos con un test de aceptaci√≥n (o del nivel de granularidad m√°s alto que podamos) que nos ayudar√° a
mantener el foco en la funcionalidad que queremos resolver. En ocasiones, este test puede estar fallando durante varias
horas porque necesite de otros ciclos complementarios m√°s peque√±os que nos ayuden avanzar (el ejemplo anterior era tan
sencillo que no lo hemos necesitado). Para esos ciclos complementarios es donde podemos hacer uso de flujos como TDD
cl√°sico (√∫til para avanzar en piezas de bajo nivel como funciones, clases, servicios) y herramientas como Testing
Library (para probar los diversos componentes que construyan la interfaz) o _simplemente_ Jest (para l√≥gica de negocio
como controladores, funciones de utilidad, etc.).

## Otras referencias

- Adem√°s de los enlaces contenidos en el art√≠culo, pod√©is encontrar m√°s referencias a TDD en
  [esta p√°gina](https://www.notion.so/codecoolture/Public-References-50b1e927fe1641748f95610353e97b7f).
- Cypress tiene una secci√≥n de [mejores pr√°cticas](https://docs.cypress.io/guides/references/best-practices.html) con
  algunos consejos muy √∫tiles sobre c√≥mo escribir pruebas de aceptaci√≥n.
- [Kent C. Dodds](https://twitter.com/kentcdodds/) (creador de Testing Library) tiene bastantes art√≠culos relacionados
  con testing de aplicaciones front-end (desde TDD hasta diferentes estrategias de testing). Pod√©is encontrarlos en
  [su blog](https://kentcdodds.com/blog?q=testing).
