---
date: "2019-12-12"
language: "Espa침ol"
spoiler:
  "쯈u칠 es ATDD? Imag칤nate aplicar TDD no s칩lo para resolver peque침as piezas de
  funcionalidad si no para conseguir un sistema desplegable en cada iteraci칩n."
title: "Aplicando ATDD para resolver El Juego de la Vida"
url: "/blog/applying-atdd-to-game-of-life"
published: true
collections:
  - tdd
---

# Aplicando ATDD para resolver El Juego de la Vida

> Nota: en la literatura, ATDD suele ir acompa침ado de un conjunto de pr치cticas y
> herramientas m치s amplio que lo descrito en este art칤culo. Mi objetivo aqu칤 es
> transmitir mi experiencia sobre c칩mo aplicar parte de sus principios para
> mejorar nuestra productividad a la hora de resolver determinados problemas,
> visto 칰nicamente desde el plano de desarrollo de software.

Una de las situaciones m치s habituales que me he encontrado en los 칰ltimos a침os
cuando facilito coding dojos o coderetreats (donde muchas personas se enfrentan
por primera vez a resolver una _kata_ aplicando metodolog칤as como TDD) es
observar c칩mo los participantes empiezan atacando el problema de una manera que
no les ayuda a avanzar, sino m치s bien les obliga a perderse en peque침os detalles
de implementaci칩n o incluso a sufrir de cierta _par치lisis por an치lisis_.

Al principio, yo tambi칠n pensaba que aplicar TDD deber칤a ser suficiente por s칤
mismo para evitar esa fricci칩n inicial y tener _working software_ lo m치s r치pido
posible, pero tras observarlo (y sufrirlo) durante varios a침os, me he dado
cuenta que no siempre es as칤. Cuando empezamos a trabajar con TDD es habitual
que tratemos de solucionar el problema desde aquellos puntos donde nos es m치s
sencillo poder aplicarlo (peque침as piezas de bajo nivel, como una funci칩n
sencilla), aunque no sean las partes que nos ayuden a llegar antes a resolver el
problema (y por tanto, a entregar valor).

Como parte de la preparaci칩n para facilitar el
[GDCR19](https://www.coderetreat.org/), estuve trabajando en resolver el Juego
de la Vida utilizando un enfoque basado en
[ATDD](https://en.wikipedia.org/wiki/Acceptance_test%E2%80%93driven_development)
(_acceptance test-driven development_), una aplicaci칩n de TDD que nos obliga a
pensar en pruebas de muy alto nivel (aceptaci칩n) con la idea de tener una
versi칩n desplegable de nuestro sistema con cada iteraci칩n.

## El s칤ndrome de la p치gina en blanco, o _ese_ primer test

Una de las ventajas de aplicar ATDD es que esa primera _crisis_ sobre c칩mo
atacar el problema me vino resuelta casi de base. En este caso, sab칤a que el
sistema deb칤a ser un CLI que, a partir de un fichero de entrada, generase un
fichero de salida con la siguiente evoluci칩n del tablero
([aqu칤](http://codingdojo.org/kata/GameOfLife/#problem-description) ten칠is un
enlace con las reglas del juego).

La primera porci칩n de funcionalidad m칤nima (de alto nivel) que se me ocurri칩
implementar fue un CLI que, dadas las condiciones anteriores, supiera
evolucionar un tablero con despoblaci칩n.

Seguramente, esta sea la diferencia m치s notable frente a tratar de resolver el
problema utilizando (칰nicamente) TDD a nivel unitario (de ahora en adelante,
UTDD -aunque no creo que este concepto est칠 definido en ning칰n sitio 游땐). Con
UTDD nos vemos _obligados_ a detectar desde el principio una primera entidad
sobre la que escribir los tests, lo que en muchas ocasiones me ha hecho perder
el foco y caer en la trampa del
[Big Design Up Front](https://wiki.c2.com/?BigDesignUpFront).

```ts
const subject = join(__dirname, "../src/cli.ts");

it("supports underpopulation", () => {
  const inputFilename = join(__dirname, "./fixtures/underpopulation");
  const outputFilename = join(__dirname, "./results/underpopulation");

  play(`${subject} --input=${inputFilename} --output=${outputFilename}`);

  const result = getResult(outputFilename);

  expect(result).toEqual(["0 0 0", "0 0 0", "0 0 0"].join("\n"));
});
```

Pero vayamos paso a paso por el test anterior:

- La funci칩n `play` es un simple envoltorio que ejecuta en un shell la
  instrucci칩n indicada. En este caso, nuestro ejecutable es el fichero
  `src/cli.ts` y se le pasan como par치metro ambos: el fichero de entrada con el
  tablero inicial y el fichero de salida donde guardar la evoluci칩n.
- Una vez ejecutado el script, recuperamos el resultado a partir del fichero de
  salida indicado y comprobamos que sea el resultado esperado.

ATDD sigue el mismo ciclo Red-Green-Refactor que TDD, por lo que en esta primera
iteraci칩n hemos sentado las expectativas tanto de un primer comportamiento del
sistema como de su propia interfaz para operar, sin tener a칰n nada de c칩digo de
producci칩n implementado. Si est치is acostumbradas a trabajar con UTDD, es posible
que este primer test os parezca _demasiado grande_. Y es que con ATDD el **ciclo
de feedback** es mucho m치s largo.

## A침adiendo nuevos comportamientos

Con el test anterior en verde, ya dispondr칤amos de una versi칩n 0.1.0 de nuestro
Juego de la Vida 游뗵 Un CLI que, a partir de un fichero de entrada, ser칤a capaz
de evolucionar el tablero detectando aquellas c칠lulas que sufran de despoblaci칩n
y guardando el resultado en el fichero de salida indicado.

Pero para implementar el Juego de la Vida de manera completa, hay que tener en
cuenta tambi칠n otros escenarios. El enfoque que apliqu칠 para ello fue ir creando
un nuevo test para cada nuevo comportamiento. As칤 pues, tras implementar el
soporte para despoblaci칩n, el siguiente en la lista era el escenario de
sobrepoblaci칩n.

Con esa prueba tambi칠n en verde, tendr칤amos una nueva versi칩n 0.2.0 del sistema
lista para desplegar; esta vez, soportando ya un nuevo escenario. Este mismo
flujo se utilizar칤a para implementar el resto de reglas.

> Cada nuevo test define un nuevo comportamiento de alto nivel en el sistema. Al
> resolverlo, nuestro software deber칤a estar listo para ser desplegado.

## ATDD y productividad

Seguramente, aplicar ATDD tampoco me hubiese ayudado a terminar de implementar
el Juego de la Vida en los 45 minutos que duran las sesiones de un coderetreat
游뗶, pero s칤 creo que me habr칤a permitido acercarme mucho m치s que si hubiese
intentado solucionar el sistema siguiendo una estrategia _bottom-up_.

Trabajar con tests de aceptaci칩n me ayud칩 a ganar foco y programar r치pidamente
una soluci칩n que los pusiese en verde. Sentir que con cada prueba disfrutas de
un sistema desplegable (aunque su implementaci칩n no sea perfecta a nivel de
dise침o) me parece un gran _boost_ de productividad. Con 4 pruebas, tienes las
reglas de negocio del Juego de la Vida cubiertas y puedes empezar a aplicar
_refactoring_ para extraer comportamientos a nuevas entidades de manera muy
confiable (los test de aceptaci칩n te aseguran que el sistema funciona punto a
punto -y esto, cuando sueles trabajar con muchos peque침os tests unitarios, est치
muy bien).

## ATDD y UTDD

El Juego de la Vida es un problema sencillo, que pr치cticamente se resuelve con
unas pocas l칤neas de c칩digo. En sistemas m치s sofisticados, donde estemos
implementando funcionalidad m치s compleja, es muy habitual mezclar ambos ciclos
para disfrutar de las ventajas de ambos enfoques (lo m치s habitual es que
trabajemos con c칩digo _legacy_, donde aplicar UTDD es _sencillo_ al tener muchas
entidades de dominio ya modeladas en nuestro sistema).

Juntar ambas estrategias termina generando un _ciclo de ciclos_, donde el test
de aceptaci칩n est치 en rojo mientras que vamos aplicando ciclos de UTDD para
tratar de ponerlo en verde (y terminar de implementar ese nuevo comportamiento
de alto nivel en el sistema).

## Contenido relacionado

Si os hab칠is quedado con ganas de investigar un poco m치s, el libro
[Growing Object-Oriented Software, Guided by Tests](https://www.amazon.es/Growing-Object-Oriented-Software-Addison-Wesley-Signature-ebook/dp/B002TIOYVW)
cubre muy bien (y en profundidad) esta manera de trabajar y resolver los
problemas. Adem치s, he publicado en
[GitHub](https://github.com/sergioalvz/practice/tree/master/game-of-life-atdd)
la implementaci칩n que utilic칠 para practicar con este enfoque mientras resolv칤a
el Juego de la Vida.

La estrategias comentadas en este art칤culo tambi칠n se representan en la
literatura a trav칠s de los conceptos de **Inside Out** y **Outside In** (que se
cubren en detalle en
[este art칤culo](https://8thlight.com/blog/georgina-mcfadyen/2016/06/27/inside-out-tdd-vs-outside-in.html)).
